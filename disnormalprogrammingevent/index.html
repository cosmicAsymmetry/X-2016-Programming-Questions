<!DOCTYPE html>
<html>
	<head>
		<title>Programming &middot; MINET X</title>
		<meta charset="utf-8">
		<meta name="author" content="The MINET Team">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="css/app.css">
		<link rel="stylesheet" type="text/css" href="css/skeleton.css">
		<link rel="stylesheet" type="text/css" href="http://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
		<link rel="icon" type="image/png" href="img/icon.png">
		<link rel="apple-touch-icon-precomposed" href="img/icon.png">
		<meta name="theme-color" content="#2979ff">
	</head>

	<body>

		<div class="container">
			
			<div class="row">
				
				<div class="three columns child">
					
					<header>
						
						<a href="#" class="handletter">MINET</a> 
						<img class="logo" src="img/x.png"></img>

					</header>

					<div class="rounds-list">
						
						<div class="list" id="round-one">
							<span class="counter">0</span>
							<p>Introduction</p>
						</div>

						<div class="list" id="round-two">
							<span class="counter">1</span>
							<p>Deterministic Finite Automata</p>
						</div>

						<div class="list" id="round-three">
							<span class="counter">2</span>
							<p>Nondeterministic Finite Automata</p>
						</div>

						<div class="list" id="round-four">
							<span class="counter">3</span>
							<p>Pushdown Automata</p>
						</div>

						<div class="list" id="round-five">
							<span class="counter">4</span>
							<p>Turing Machines</p>
						</div>

						<div class="list" id="round-six">
							<span class="counter">5</span>
							<p>Questions</p>
						</div>
					</div>
				</div>
				<div class="nine columns child">

					<div data-content="landing">
					
						<h1>Programming &middot; X 2015</h1>
						<p>
Welcome to Day 1 of MINET X 2016.  We hope you have as much fun solving the problems as we had making them. You have been provided with the Code::Blocks and Turbo C++ environments. The event will be three hours long. The highest amount possible in this event is 1,000$. Everyone's score will be relative to the team with the highest score which have a direct effect to your funds. Whenever you wish to attempt a question, raise your hand and one of us will come to you. If you have any questions about the problems, do not be afraid to ask them of us. Have fun, and Make beautiful machines. Best of luck!
						</p>

					</div>

					<div data-content="round-one">

						<h1>Introduction</h1>

						<div class="question">
							<blockquote>"An object is of the highest degree of complexity if it can do very difficult and involved things.”  <br><br>&mdash; John von Neumann, Theory Of Self Reproducing Automata</blockquote>
							<p id="question">
								The term "Automata" is derived from the Greek word "αὐτόματα" which means "self-acting". An automaton (Automata in plural) is an abstract self-propelled computing device which follows a predetermined sequence of operations automatically.<br><br>
								Every computational device (everything from phones and calculators to logic gates and compilers) has limitations and no device can be termed as a one size fits all for computation. The study of Automata Theory explores these limitations and advantages of different automata. This subject plays a big role in Mathematics and Theoretical Computer Science as a part of it deals with perhaps the most important question of our century $P$ $vs.$ $NP$.<br><br>
							</p>
						</div>

					</div>

					<div data-content="round-two">

						<h1>Deterministic Finite Automata(DFAs)</h1>

						<div class="question">
							
						<p id="question">
							We don’t realize it but we come across several DFAs in our daily life and they are beloved to Code Golfers as these  abstract machines are used to compute Regular Expressions(regex).<br><br>
DFAs have a finite amount of memory, more specifically a finite number of states that the machine can be in, it does not depend on the size of input given to it. To give you a few rudimentary examples consider the following:
						</p>
						<ol>
							<li>
								<b>An electric switch.</b><br>	
								It can be in two states, ON and OFF.
								<center><img src="img/DFAe1.png" width="50%"></center>
								A $PUSH$ operation on a state changes its state and only a $PUSH$ operation can change states which makes $PUSH$ the language of this DFA. If you start on $ON$ and give an even number of PUSH operations your final state will be $ON$ and if you give an odd number of $PUSH$ operations your final state will be $OFF$.<br>
The computation would be as follows:<br>
							<ul>
							<li>
							$\delta(ON, PUSH) = OFF$	
							</li>
							<li>$\delta(OFF, PUSH) = ON$</li>
							</ul>
							Where ON and OFF are the states, and PUSH is the input symbol.
							<p><b>Note:</b>The notation used here will be explained in detail a bit later.</p>
							</li>
							<li><b>A Fan regulator</b><br>
It has a total of four states, Off, Low, Medium and High. You can change between the states by either turning the regulator Clockwise or Anticlockwise which we will represent as $C$ and $A$ respectively. Hence, $(C,A)$ is the language of this DFA.
<center><img src="img/DFAe2.png" width="100%"></center>
Here, $q_0$ is the start state and the Off state of the regulator, $q_1$ is Low, $q_2$ is Medium and $q_3$ is High.<br>
So, if I were to give a string of operations, say, $w = ‘AACCCC’$. The machine would follow the following path:<br>
$q_0 \rightarrow q_3 \rightarrow q_2 \rightarrow q_3 \rightarrow q_0 \rightarrow q_1 \rightarrow q_2$<br>
Over here we see that the final state reached by the string, $w$ is $q_2$. But the person who made this DFA wanted the Fan off. Hence, in this diagram we notice that $q_0$ is an bolded (has an extra circle around it); that is used to denote an accept state of a DFA. A string of operations is only accepted if it finishes at an accept state. In the case of $w$, it doesn’t reach an accept state hence, it is not accepted by this DFA.
							</li>
						</ol>
<br><br>
<b>Notation and Rules</b><br>
A DFA is defined as a five tuple, $D = (Q, \Sigma, \delta, q_0, F)$ where:
<ul>
	<li>$Q$ is the set of states. This is a set of all states in the DFA, even the start state, $q_0$ and final set of states $F$ are present in this set.</li>
	<li>$\Sigma$ is the language of the DFA.</li>
	<li>$\delta$ is the transition function. The transition function is used to transition between states. In a DFA it’s in the form $Q × \Sigma \rightarrow Q$ where $Q$ is the set of states and $\Sigma$ are the symbols.</li>
	<li>$q_0$ is the start state.</li>
	<li>$F$ is the set of accept states</li>
</ul>
<b>Note:</b> A <b>dump state</b> is a set of states from which the computation can not end up at any of the accept states. <br><br>
<b>Languages</b>
<p>
	Languages of Abstract machines are not too different from the languages that we’re familiar with. In English we have a set of words formed over an alphabet similarly, a simple way to think about languages of abstract machines is as a set of strings $w$ formed over an alphabet $\Sigma$.<br><br>
	<b>Star Operation:</b> $A^* = \{x_1, x_2, x_3, x_k |  k \geq 0$ and $x_i \in A\}$<br>
	When we say, $\Sigma^* = \{a, b\}$ we actually mean all possible strings that could be made with a and b, which are:<br>
	$a, b, aa, bb, ab, ba, aaa, bbb, aba…$<br>
	And when we put a superscript over the alphabet we denote the maximum length of the string with that. I.e,<br>
	$w = \{\Sigma^2|$ $\Sigma = \{a, b\}\}$ we mean:
	$w = {a, b, aa, bb, ab, ba}$<br>
	There can be several DFAs that accept one language but not vice versa.
</p><br><br>
<b>Examples of DFAs</b><br>
A DFA which accepts a string $w$, if $w$ does not contain the substring $101$.
<img src="img/DFAe3.png" width="100%"><br>
For this example:
<ul>
	<li>$Q = {q_0, q_1, q_2, q_3}$</li>
	<li>$\Sigma = \{0,1\}^*$ </li>
	<li>$\delta(q_0, 0) = q_0$ and $\delta(q_0,1)=q_1$ and so on.</li>
	<li>$q_0$ is the start state.</li>
	<li>$F = \{q_0, q_1, q_2\}$</li>
</ul><br>
So if we were to run the string, $w = “100101”$, the computation would be as follows:
<ol>
	<li>$\delta(q_0, 1) = q_1$</li>
	<li>$\delta(q_1, 0) = q_2$</li>
	<li>$\delta(q_2, 0) = q_0$</li>
	<li>$\delta(q_0, 1) = q_1$</li>
	<li>$\delta(q_1, 0) = q_2$</li>
	<li>$\delta(q_2, 1) = q_3$</li>
</ol>
Since $q_3$ is not one of the accept states, the string $w$ will not be accepted by the DFA.<br>
Also, $q_3$ here is a <b>dump state</b>.<br><br>

A DFA that accepts a string $w$, if the <b>length is divisible by 4</b>.<br><br>
<img src="img/DFAe4.png" width="100%"><br><br>
For this Example:
<ul>
	<li>$Q = {q_0, q_1, q_2, q_3}$</li>
	<li>$\Sigma = \{0,1\}^*$ </li>
	<li>$\delta(q_0, 0) = q_0$ and $\delta(q_0,1)=q_1$ and so on.</li>
	<li>$q_0$ is the start state.</li>
	<li>$F = \{q_0\}$</li>
</ul>
So if we were to run the string, w = “1101”, the computation would be as follows:
<ul>
	<li>$\delta(q_0, 1) = q_1$</li>
	<li>$\delta(q_1, 0) = q_2$</li>
	<li>$\delta(q_2, 0) = q_3$</li>
	<li>$\delta(q_0, 1) = q_0$</li>
</ul><br>
Since $q_0$ is the accept state, the string $w$ will be accepted by the DFA.
</div>
						
					</div>

					<div data-content="round-three">

						<h1>Nondeterministic Finite Automata</h1>
						
						<div class="question">
							
							<p id="question">
								<b>Introduction</b><br><br>
								An NFA, similar to a DFA, consumes a string of input symbols.  For each input symbol, it transitions to a new state until all input symbols have been consumed. Unlike a DFA, it is non-deterministic, i.e., for some state and input symbol, the next state may be nothing or one or two or more possible states. Thus, in the formal definition, the next state is an element of the power set of the states, which is a set of states to be considered at once. The notion of accepting an input is similar to that for the DFA. When the last input symbol is consumed, the NFA accepts if and only if <b>there is some set of transitions that will take it to an accepting state.</b> Equivalently, it rejects, if, no matter what transitions are applied, it would not end in an accepting state. 
								<br><br>
								<b>Notation and Rules</b><br>
								It is defined as a five tuple, $N = (Q, \sigma, \delta, q_0, F)$ where:<br>
								<ul>
	<li>$Q$ is the set of states. This is a set of all states in the DFA, even the start state, $q_0$ and final set of states $F$ are present in this set.</li>
	<li>$\Sigma$ is the language of the DFA.</li>
	<li>$\delta$ is transition function that takes two arguments a state and an input symbol and it returns a subset of $Q$ that is, $Q \times (\Sigma \cup \{\epsilon\}) \rightarrow 2^Q$ where $2^Q$ is the power set of $N$ (the set of subsets of $Q$).</li>
	<li>$q_0$ is the start state.</li>
	<li>$F$ is the set of accept states</li>
</ul><br>
$\epsilon$ marks state transitions that do not consume any input. The symbol ε does not belong to any alphabet These transitions thus express the non-determinism of the automaton.<br><br>
<b>Examples of NFAs</b><br>
<ol>
	<li>
An NFA which accepts a string $w$, if it ends with the substring $“00”$.<br>
<img src="img/NFAe1.png" width="100%">
For this example:
<ul>
	<li>$Q = {q_0, q_1, q_2}$</li>
	<li>$\Sigma = \{0,1\}^*$ </li>
	<li>$q_0$ is the start state.</li>
	<li>$F = \{q_2\}$</li>
</ul><br>
For the string “0100”, the computation is as follows:
<table>
	<th>Input Symbol</th>
	<th>States</th>
	<tr>
		<td>$0$</td>
		<td>${q_0, q_1}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>${q_0}$</td>
	</tr>
	<tr>
		<td>$0$</td>
		<td>${q_0, q_1}$</td>
	</tr>
	<tr>
		<td>$0$</td>
		<td>${q_0, q_1}$</td>
	</tr>
</table><br>
Since at least one of the computation paths leads to an accept state($q_2$), $w$ is accepted by the NFA.<br><br>		
	</li>
	<li>
An NFA which accepts a string $w$,  where length of $w$ is either divisible by 2, or 3, or both.
<img src="img/NFAe2.png" width="100%">
For the string “11111”, the computation would be as follows:<br>
<table>
	<th>Input Symbol</th>
	<th>States</th>
	<tr>
		<td>$\epsilon$</td>
		<td>$\{q_0,q_3\}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>$\{q_2,q_4\}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>$\{q_1,q_5\}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>$\{q_2,q_3\}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>$\{q_1,q_4\}$</td>
	</tr>
	<tr>
		<td>$1$</td>
		<td>$\{q_2,q_5\}$</td>
	</tr>
</table><br>
Since $q_2$ and $q_5$ are not part of the accept states, the string won’t be accepted.

	</li>
</ol>


								<br>								

							</p>

						</div>

					</div>

					<div data-content="round-four">

						<h1>Pushdown Automata</h1>
						
						<div class="question" style="overflow: auto">
							<p id="question">
								<b>Introduction</b><br>
A pushdown automata is a finite automata with a  memory model of a stack attached to it. There are two types of PDAs, Deterministic Pushdown automata(DFA+Stack), DPDA and Nondeterministic Pushdown Automata(NFA+Stack), NDPA.
							</p><br><br>
<p id="question">
	<b>Notation and Rules</b><br>
A PDA is defined as a seven tuple, $P = (Q, \Sigma, \delta, q_0, Z_0, F, \Gamma)$ where:
<ul>
	<li>$Q$ is the set of states. This is a set of all states in the DFA, even the start state, $q_0$ and final set of states $F$ are present in this set.</li>
	<li>$\Sigma$ is the language of the DFA.</li>
	<li>$\delta$ is the transition function. The transition function is used to transition between states. In a DFA it’s in the form $Q × (\Sigma \cup \{\epsilon\})\rightarrow Q × \Gamma^*$ where $Q$ is the set of states, $\Sigma$ are the symbols. and $\Gamma$ is the alphabet of the stack</li>
	<li>$q_0$ is the start state.</li>
	<li>$Z_0$ is the bottom of the stack.</li>
	<li>$F$ is the set of accept states</li>
</ul>
They differ from Finite Automata in two ways. One, they can use the top of the stack to decide which transition to take. Two, they can manipulate the stack as part of performing a transition.
<center><img src="img/PDAe1.png" width="50%"></center><br><br>
<b>Examples of PDAs</b>
<ol>
	<li>Let’s consider a language $L$ where $L = \{0^n1^n| n \geq 0\}$ Let the DPDA be called $M$ where $M=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$ where:
	<ul>
		<li><b>states:</b>$Q = \{p,q,r\}$</li>
		<li><b>Input alphabet:</b>$\Sigma = \{0,1\}$</li>
		<li><b>stack alphabet:</b>$\Gamma = \{A,Z\}$</li>
		<li><b>Start state:</b> $q_0 = p$</li>
		<li><b>Start stack symbol:</b> $Z$</li>
		<li><b>Accepting states:</b> $F = \{r\}$</li>
		<li>$M$ is a DPDA</li>
	</ul>
	<center><img src="img/PDAe2.png" width="75%"></center><br>
	The transition relation $\delta$ consists of the following five instructions:<br>
	<ul>
		<li>$(p,0,Z) \rightarrow (p,AZ)$</li>
		<li>$(p,0,A) \rightarrow (p,AA)$</li>
		<li>$(p,1,A) \rightarrow (q,\epsilon)$</li>
		<li>$(q,1,A) \rightarrow (q,\epsilon)$and,</li>
		<li>$(q,\epsilon,Z)(r,Z)$</li>
	</ul>
</p>
<p id="question">
	In words, the first two instructions say that in state $p$ any time the symbol $0$ is read, one $A$ is pushed onto the stack. Pushing symbol $A$ on top of another $A$ is formalized as replacing top $A$ by $AA$ (and similarly for pushing symbol $A$ on top of a $Z$ ).<br>
The third instruction says that in state $q$, for each symbol $1$ read, one $A$ is popped.
Finally, the fourth instruction says that the machine may move from state $q$ to accepting state $r$ only when the stack consists of a single $Z$ .
</p>

	</li>
	<li>Let’s consider a language $L$ where $L = ww^R$ $|$ $w = (a+b)^*$<br>
	<img src="img/PDAe3.png"><br>
	The dollar sign here has been replaced with $D$.<br>
	Initially we put a special symbol $D$ into the empty stack. At state $q_2$, the $w$ is being read. In state $q_3$, each $a$ or $b$ is popped when it matches the input. If any other input is given, the PDA will go to a dead state. When we reach that special symbol $D$, we go to the accepting state $q_4$.
	</li>
</ol>


</div>

					</div>

					<div data-content="round-five">

						<h1>Turing Machines</h1>
						
						<div class="question">
							
							<p id="question">

							</p>

						</div>
</div>
					<div data-content="round-six">

						<h1>Questions</h1>
						
						<div class="question">
							
							<p id="question">
								<strong>1</strong>
								Construct DFA for binary strings whose first and last symbol are the same. <br><b style="color:#696969;float:right;">0.5</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>2</strong>
								Construct a DFA for $L$, given $L=\{ab^5 wb^4\}$ where $w=\{a, b\}^*$.<br>
								<b style="color:#696969;float:right;">1</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>3</strong>
								Construct a DFA for binary strings whose decimal representations are divisible by $3$.
								<br><b style="color:#696969;float:right;">2</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>4</strong>
								Construct an NFA for binary strings that have either odd number of $0$’s,  or number of  $1$’s not divisible by $3$, or both.
								<br><b style="color:#696969;float:right;">1</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>5</strong>
								Let $L$ be the language of binary strings where every $0$ is followed by a $1$. Construct a DFA and an NFA respectively that accepts strings of $L$ with minimum number of states.
							<br><b style="color:#696969;float:right;">2</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>6</strong>
								Construct NFA that recognizes language generated by ${abba, bab}^*$.
							<br><b style="color:#696969;float:right;">0.5</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>7</strong>
								Construct a pushdown automaton that accepts the set $L$ of all strings in ${a, b}^*$ having an odd length and whose middle symbol is $b$.
								<br><b style="color:#696969;float:right;">2</b> 
							</p>

						</div>

						<div class="question">
							<p id="question">
								<strong>8</strong>
								Construct pushdown automata for the language 
$w ∈ {a, b}^*$, such that for every $2$ $a$’s, there are $3$ $b$’s.
							<br><b style="color:#696969;float:right;">2</b> 
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>9</strong>
								Construct a PDA which accepts strings of the language $\{$$ [, ], \{, \}, (, )$ $\}^*$ containing nested pairs of brackets. For example, “[[[{{(((())))}}]]]”.
							<br><b style="color:#696969;float:right;">2</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>10</strong>
								Construct a DFA The set of all binary strings that contain at least two $0$’s and at most one $1$.
								<br><b style="color:#696969;float:right;">3</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>11</strong>
								Construct a DFA recognizing binary numbers whose decimal representations are multiples of 5.
								<br><b style="color:#696969;float:right;">4</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>12</strong>
								Make a turing machine that multiplies two number given in binary. The numbers  will be given in binary separated by spaces. Output in binary.
								<br><b style="color:#696969;float:right;">6</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>13</strong>
								Make a turing machine that writes the digits of the sequence 0 0 1 0 1 1 0 1 1 1 0 1 1 1 1 0 ...
								<br><b style="color:#696969;float:right;">6</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>14</strong>
								Make a turing machine that converts a number from binary to decimal.
								<br><b style="color:#696969;float:right;">8</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>15</strong>
								Make a turing machine that checks if a given number is a prime. The input will be given in binary form.
								<br><b style="color:#696969;float:right;">22</b>
							</p>

						</div>

						<div class="question">
							
							<p id="question">
								<strong>10</strong>
								Distinguishability of quantum states
								We have seen that the probability of measuring an outcome in a quantum system in the modulus squared of the corresponding coefficient. Now, I give you two systems (photons, say):
								$$\ket{\psi_1}= (\ket{0}+\ket{1})/\sqrt{2},\ket{\psi_2}= (\ket{0}-\ket{1})/\sqrt{2}$$

								Note that all the probablities are half, so measuring both the states would give you the same results. How do you, then, distinguish between them? Feel free to prepare any more photons and conduct thought experiments with them.
							</p>

						</div>
				</div>

			</div>

		</div>

		<!-- <div class="question">
			
			<p id="question"><strong>1</strong> Trademarked Transaction</p>
      		<form class="cryptx">
				<input type="text" placeholder="Answer" name="answer" class="answer-box" autofocus autocomplete="off">
				<input type="submit">
			</form>

		</div> -->

		<script src="//use.typekit.net/dbe5tbi.js"></script>
		<script>try{Typekit.load();}catch(e){}</script>
		<script type="text/javascript" src="js/jquery-1.10.1.min.js"></script>
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
		  TeX: {
		     Macros: {
		      dd: '{\\rm d}',
		      CC: '{\\mathbb C}',
		      RR: '{\\mathbb R}',
		      ZZ: '{\\mathbb Z}',
		      OO: '{\\mathbb O}',
		      O: '{\\mathcal O}',
		      HHH: '{\\mathbb H}',
		      NN: '{\\mathbb N}',
		      NNN: '{\\mathcal N}',
		      FF: '{\\mathcal F}',
		      HH: '{\\mathcal H}',
		      LL: '{\\mathcal L}',
		      meV: '{\\,\\,{\\rm meV}}',
		      eV: '{\\,\\,{\\rm eV}}',
		      keV: '{\\,\\,{\\rm keV}}',
		      MeV: '{\\,\\,{\\rm MeV}}',
		      GeV: '{\\,\\,{\\rm GeV}}',
		      TeV: '{\\,\\,{\\rm TeV}}',
		      diag: '{\\rm diag}',
		      pfrac: ['\\frac{\\partial #1}{\\partial #2}',2],
		      ddfrac: ['\\frac{{\\rm d} #1}{{\\rm d} #2}',2],
		      bold: ['{\\bf #1}',1],
		      zav: ['\\left({#1}\\right)',1],
		      zzav: ['\\left[{#1}\\right]',1],
		      eq: ['\\begin{align} #1 \\end{align}',1],
		      abs: ['\\left|{#1}\\right|',1],
		      braket: ['\\langle{#1}|{#2}\\rangle',2],
		      bra: ['\\langle{#1}|',1],
		      ket: ['{|{#1}\\rangle}',1],
		      iddots: "{\\kern3mu\\raise1mu{.}\\kern3mu\\raise6mu{.}\\kern3mu\\raise12mu{.}}"
		    }
		  },
		  MathZoom: {
		    delay: 600
		  },
		  styles: {
		  ".MathJax .merror": {
		    "background-color": "#33FF88 !important",
		    color:   "#CC00CC !important",
		    border:  "1px solid #CCAA00 !important",
		    padding: "1px 3px",
		    "font-style": "normal",
		    "font-size":  "90%"
		  },
		  "#MathJax_Zoom": {color: "#335544",
		  "background-color": "#AAFFDD"
		  },
		  ".MathJax_Preview": {color: "#DDFFCC",
		  "background-color": "#446655"
		  }
		  },
		    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
		  });
		</script>

		<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		<script type="text/javascript">
		$(".list").click(function() {
			$(this).find("ul").slideDown();
			$(this).find("i").css("display", "inline");
		});
		$(".list i").click(function(event) {
			event.stopPropagation();
			$(this).parent().find("ul").slideUp();
			$(this).css("display", "none");
		});
		$(".list").click(function() {
			var roundCount = $(this).attr('id');
			$("div[data-content]").css("display", "none");
			$('div[data-content=' + roundCount + ']').css("display", "block");
		});
		</script>
	</body>
</html>